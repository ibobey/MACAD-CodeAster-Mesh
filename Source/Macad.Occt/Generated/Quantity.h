// Generated wrapper code for package Quantity

#pragma once

#include "Standard.h"

namespace Macad
{
namespace Occt
{
//---------------------------------------------------------------------
//  Enum  Quantity_NameOfColor
//---------------------------------------------------------------------
/// <summary>
/// Definition of names of known colors.
/// The names come (mostly) from the X11 specification.
/// </summary>
public enum class Quantity_NameOfColor
{
    BLACK = 0,
    MATRABLUE = 1,
    MATRAGRAY = 2,
    ALICEBLUE = 3,
    ANTIQUEWHITE = 4,
    ANTIQUEWHITE1 = 5,
    ANTIQUEWHITE2 = 6,
    ANTIQUEWHITE3 = 7,
    ANTIQUEWHITE4 = 8,
    AQUAMARINE1 = 9,
    AQUAMARINE2 = 10,
    AQUAMARINE4 = 11,
    AZURE = 12,
    AZURE2 = 13,
    AZURE3 = 14,
    AZURE4 = 15,
    BEIGE = 16,
    BISQUE = 17,
    BISQUE2 = 18,
    BISQUE3 = 19,
    BISQUE4 = 20,
    BLANCHEDALMOND = 21,
    BLUE = 22,
    BLUE1 = 22,
    BLUE2 = 23,
    BLUE3 = 24,
    BLUE4 = 25,
    BLUEVIOLET = 26,
    BROWN = 27,
    BROWN1 = 28,
    BROWN2 = 29,
    BROWN3 = 30,
    BROWN4 = 31,
    BURLYWOOD = 32,
    BURLYWOOD1 = 33,
    BURLYWOOD2 = 34,
    BURLYWOOD3 = 35,
    BURLYWOOD4 = 36,
    CADETBLUE = 37,
    CADETBLUE1 = 38,
    CADETBLUE2 = 39,
    CADETBLUE3 = 40,
    CADETBLUE4 = 41,
    CHARTREUSE = 42,
    CHARTREUSE1 = 42,
    CHARTREUSE2 = 43,
    CHARTREUSE3 = 44,
    CHARTREUSE4 = 45,
    CHOCOLATE = 46,
    CHOCOLATE1 = 47,
    CHOCOLATE2 = 48,
    CHOCOLATE3 = 49,
    CHOCOLATE4 = 50,
    CORAL = 51,
    CORAL1 = 52,
    CORAL2 = 53,
    CORAL3 = 54,
    CORAL4 = 55,
    CORNFLOWERBLUE = 56,
    CORNSILK1 = 57,
    CORNSILK2 = 58,
    CORNSILK3 = 59,
    CORNSILK4 = 60,
    CYAN = 61,
    CYAN1 = 61,
    CYAN2 = 62,
    CYAN3 = 63,
    CYAN4 = 64,
    DARKGOLDENROD = 65,
    DARKGOLDENROD1 = 66,
    DARKGOLDENROD2 = 67,
    DARKGOLDENROD3 = 68,
    DARKGOLDENROD4 = 69,
    DARKGREEN = 70,
    DARKKHAKI = 71,
    DARKOLIVEGREEN = 72,
    DARKOLIVEGREEN1 = 73,
    DARKOLIVEGREEN2 = 74,
    DARKOLIVEGREEN3 = 75,
    DARKOLIVEGREEN4 = 76,
    DARKORANGE = 77,
    DARKORANGE1 = 78,
    DARKORANGE2 = 79,
    DARKORANGE3 = 80,
    DARKORANGE4 = 81,
    DARKORCHID = 82,
    DARKORCHID1 = 83,
    DARKORCHID2 = 84,
    DARKORCHID3 = 85,
    DARKORCHID4 = 86,
    DARKSALMON = 87,
    DARKSEAGREEN = 88,
    DARKSEAGREEN1 = 89,
    DARKSEAGREEN2 = 90,
    DARKSEAGREEN3 = 91,
    DARKSEAGREEN4 = 92,
    DARKSLATEBLUE = 93,
    DARKSLATEGRAY1 = 94,
    DARKSLATEGRAY2 = 95,
    DARKSLATEGRAY3 = 96,
    DARKSLATEGRAY4 = 97,
    DARKSLATEGRAY = 98,
    DARKTURQUOISE = 99,
    DARKVIOLET = 100,
    DEEPPINK = 101,
    DEEPPINK2 = 102,
    DEEPPINK3 = 103,
    DEEPPINK4 = 104,
    DEEPSKYBLUE1 = 105,
    DEEPSKYBLUE2 = 106,
    DEEPSKYBLUE3 = 107,
    DEEPSKYBLUE4 = 108,
    DODGERBLUE1 = 109,
    DODGERBLUE2 = 110,
    DODGERBLUE3 = 111,
    DODGERBLUE4 = 112,
    FIREBRICK = 113,
    FIREBRICK1 = 114,
    FIREBRICK2 = 115,
    FIREBRICK3 = 116,
    FIREBRICK4 = 117,
    FLORALWHITE = 118,
    FORESTGREEN = 119,
    GAINSBORO = 120,
    GHOSTWHITE = 121,
    GOLD = 122,
    GOLD1 = 122,
    GOLD2 = 123,
    GOLD3 = 124,
    GOLD4 = 125,
    GOLDENROD = 126,
    GOLDENROD1 = 127,
    GOLDENROD2 = 128,
    GOLDENROD3 = 129,
    GOLDENROD4 = 130,
    GRAY = 131,
    GRAY0 = 132,
    GRAY1 = 133,
    GRAY2 = 134,
    GRAY3 = 135,
    GRAY4 = 136,
    GRAY5 = 137,
    GRAY6 = 138,
    GRAY7 = 139,
    GRAY8 = 140,
    GRAY9 = 141,
    GRAY10 = 142,
    GRAY11 = 143,
    GRAY12 = 144,
    GRAY13 = 145,
    GRAY14 = 146,
    GRAY15 = 147,
    GRAY16 = 148,
    GRAY17 = 149,
    GRAY18 = 150,
    GRAY19 = 151,
    GRAY20 = 152,
    GRAY21 = 153,
    GRAY22 = 154,
    GRAY23 = 155,
    GRAY24 = 156,
    GRAY25 = 157,
    GRAY26 = 158,
    GRAY27 = 159,
    GRAY28 = 160,
    GRAY29 = 161,
    GRAY30 = 162,
    GRAY31 = 163,
    GRAY32 = 164,
    GRAY33 = 165,
    GRAY34 = 166,
    GRAY35 = 167,
    GRAY36 = 168,
    GRAY37 = 169,
    GRAY38 = 170,
    GRAY39 = 171,
    GRAY40 = 172,
    GRAY41 = 173,
    GRAY42 = 174,
    GRAY43 = 175,
    GRAY44 = 176,
    GRAY45 = 177,
    GRAY46 = 178,
    GRAY47 = 179,
    GRAY48 = 180,
    GRAY49 = 181,
    GRAY50 = 182,
    GRAY51 = 183,
    GRAY52 = 184,
    GRAY53 = 185,
    GRAY54 = 186,
    GRAY55 = 187,
    GRAY56 = 188,
    GRAY57 = 189,
    GRAY58 = 190,
    GRAY59 = 191,
    GRAY60 = 192,
    GRAY61 = 193,
    GRAY62 = 194,
    GRAY63 = 195,
    GRAY64 = 196,
    GRAY65 = 197,
    GRAY66 = 198,
    GRAY67 = 199,
    GRAY68 = 200,
    GRAY69 = 201,
    GRAY70 = 202,
    GRAY71 = 203,
    GRAY72 = 204,
    GRAY73 = 205,
    GRAY74 = 206,
    GRAY75 = 207,
    GRAY76 = 208,
    GRAY77 = 209,
    GRAY78 = 210,
    GRAY79 = 211,
    GRAY80 = 212,
    GRAY81 = 213,
    GRAY82 = 214,
    GRAY83 = 215,
    GRAY85 = 216,
    GRAY86 = 217,
    GRAY87 = 218,
    GRAY88 = 219,
    GRAY89 = 220,
    GRAY90 = 221,
    GRAY91 = 222,
    GRAY92 = 223,
    GRAY93 = 224,
    GRAY94 = 225,
    GRAY95 = 226,
    GRAY97 = 227,
    GRAY98 = 228,
    GRAY99 = 229,
    GREEN = 230,
    GREEN1 = 230,
    GREEN2 = 231,
    GREEN3 = 232,
    GREEN4 = 233,
    GREENYELLOW = 234,
    HONEYDEW = 235,
    HONEYDEW2 = 236,
    HONEYDEW3 = 237,
    HONEYDEW4 = 238,
    HOTPINK = 239,
    HOTPINK1 = 240,
    HOTPINK2 = 241,
    HOTPINK3 = 242,
    HOTPINK4 = 243,
    INDIANRED = 244,
    INDIANRED1 = 245,
    INDIANRED2 = 246,
    INDIANRED3 = 247,
    INDIANRED4 = 248,
    IVORY = 249,
    IVORY2 = 250,
    IVORY3 = 251,
    IVORY4 = 252,
    KHAKI = 253,
    KHAKI1 = 254,
    KHAKI2 = 255,
    KHAKI3 = 256,
    KHAKI4 = 257,
    LAVENDER = 258,
    LAVENDERBLUSH1 = 259,
    LAVENDERBLUSH2 = 260,
    LAVENDERBLUSH3 = 261,
    LAVENDERBLUSH4 = 262,
    LAWNGREEN = 263,
    LEMONCHIFFON1 = 264,
    LEMONCHIFFON2 = 265,
    LEMONCHIFFON3 = 266,
    LEMONCHIFFON4 = 267,
    LIGHTBLUE = 268,
    LIGHTBLUE1 = 269,
    LIGHTBLUE2 = 270,
    LIGHTBLUE3 = 271,
    LIGHTBLUE4 = 272,
    LIGHTCORAL = 273,
    LIGHTCYAN = 274,
    LIGHTCYAN1 = 274,
    LIGHTCYAN2 = 275,
    LIGHTCYAN3 = 276,
    LIGHTCYAN4 = 277,
    LIGHTGOLDENROD = 278,
    LIGHTGOLDENROD1 = 279,
    LIGHTGOLDENROD2 = 280,
    LIGHTGOLDENROD3 = 281,
    LIGHTGOLDENROD4 = 282,
    LIGHTGOLDENRODYELLOW = 283,
    LIGHTGRAY = 284,
    LIGHTPINK = 285,
    LIGHTPINK1 = 286,
    LIGHTPINK2 = 287,
    LIGHTPINK3 = 288,
    LIGHTPINK4 = 289,
    LIGHTSALMON1 = 290,
    LIGHTSALMON2 = 291,
    LIGHTSALMON3 = 292,
    LIGHTSALMON4 = 293,
    LIGHTSEAGREEN = 294,
    LIGHTSKYBLUE = 295,
    LIGHTSKYBLUE1 = 296,
    LIGHTSKYBLUE2 = 297,
    LIGHTSKYBLUE3 = 298,
    LIGHTSKYBLUE4 = 299,
    LIGHTSLATEBLUE = 300,
    LIGHTSLATEGRAY = 301,
    LIGHTSTEELBLUE = 302,
    LIGHTSTEELBLUE1 = 303,
    LIGHTSTEELBLUE2 = 304,
    LIGHTSTEELBLUE3 = 305,
    LIGHTSTEELBLUE4 = 306,
    LIGHTYELLOW = 307,
    LIGHTYELLOW2 = 308,
    LIGHTYELLOW3 = 309,
    LIGHTYELLOW4 = 310,
    LIMEGREEN = 311,
    LINEN = 312,
    MAGENTA = 313,
    MAGENTA1 = 313,
    MAGENTA2 = 314,
    MAGENTA3 = 315,
    MAGENTA4 = 316,
    MAROON = 317,
    MAROON1 = 318,
    MAROON2 = 319,
    MAROON3 = 320,
    MAROON4 = 321,
    MEDIUMAQUAMARINE = 322,
    MEDIUMORCHID = 323,
    MEDIUMORCHID1 = 324,
    MEDIUMORCHID2 = 325,
    MEDIUMORCHID3 = 326,
    MEDIUMORCHID4 = 327,
    MEDIUMPURPLE = 328,
    MEDIUMPURPLE1 = 329,
    MEDIUMPURPLE2 = 330,
    MEDIUMPURPLE3 = 331,
    MEDIUMPURPLE4 = 332,
    MEDIUMSEAGREEN = 333,
    MEDIUMSLATEBLUE = 334,
    MEDIUMSPRINGGREEN = 335,
    MEDIUMTURQUOISE = 336,
    MEDIUMVIOLETRED = 337,
    MIDNIGHTBLUE = 338,
    MINTCREAM = 339,
    MISTYROSE = 340,
    MISTYROSE2 = 341,
    MISTYROSE3 = 342,
    MISTYROSE4 = 343,
    MOCCASIN = 344,
    NAVAJOWHITE1 = 345,
    NAVAJOWHITE2 = 346,
    NAVAJOWHITE3 = 347,
    NAVAJOWHITE4 = 348,
    NAVYBLUE = 349,
    OLDLACE = 350,
    OLIVEDRAB = 351,
    OLIVEDRAB1 = 352,
    OLIVEDRAB2 = 353,
    OLIVEDRAB3 = 354,
    OLIVEDRAB4 = 355,
    ORANGE = 356,
    ORANGE1 = 356,
    ORANGE2 = 357,
    ORANGE3 = 358,
    ORANGE4 = 359,
    ORANGERED = 360,
    ORANGERED1 = 360,
    ORANGERED2 = 361,
    ORANGERED3 = 362,
    ORANGERED4 = 363,
    ORCHID = 364,
    ORCHID1 = 365,
    ORCHID2 = 366,
    ORCHID3 = 367,
    ORCHID4 = 368,
    PALEGOLDENROD = 369,
    PALEGREEN = 370,
    PALEGREEN1 = 371,
    PALEGREEN2 = 372,
    PALEGREEN3 = 373,
    PALEGREEN4 = 374,
    PALETURQUOISE = 375,
    PALETURQUOISE1 = 376,
    PALETURQUOISE2 = 377,
    PALETURQUOISE3 = 378,
    PALETURQUOISE4 = 379,
    PALEVIOLETRED = 380,
    PALEVIOLETRED1 = 381,
    PALEVIOLETRED2 = 382,
    PALEVIOLETRED3 = 383,
    PALEVIOLETRED4 = 384,
    PAPAYAWHIP = 385,
    PEACHPUFF = 386,
    PEACHPUFF2 = 387,
    PEACHPUFF3 = 388,
    PEACHPUFF4 = 389,
    PERU = 390,
    PINK = 391,
    PINK1 = 392,
    PINK2 = 393,
    PINK3 = 394,
    PINK4 = 395,
    PLUM = 396,
    PLUM1 = 397,
    PLUM2 = 398,
    PLUM3 = 399,
    PLUM4 = 400,
    POWDERBLUE = 401,
    PURPLE = 402,
    PURPLE1 = 403,
    PURPLE2 = 404,
    PURPLE3 = 405,
    PURPLE4 = 406,
    RED = 407,
    RED1 = 407,
    RED2 = 408,
    RED3 = 409,
    RED4 = 410,
    ROSYBROWN = 411,
    ROSYBROWN1 = 412,
    ROSYBROWN2 = 413,
    ROSYBROWN3 = 414,
    ROSYBROWN4 = 415,
    ROYALBLUE = 416,
    ROYALBLUE1 = 417,
    ROYALBLUE2 = 418,
    ROYALBLUE3 = 419,
    ROYALBLUE4 = 420,
    SADDLEBROWN = 421,
    SALMON = 422,
    SALMON1 = 423,
    SALMON2 = 424,
    SALMON3 = 425,
    SALMON4 = 426,
    SANDYBROWN = 427,
    SEAGREEN = 428,
    SEAGREEN1 = 429,
    SEAGREEN2 = 430,
    SEAGREEN3 = 431,
    SEAGREEN4 = 432,
    SEASHELL = 433,
    SEASHELL2 = 434,
    SEASHELL3 = 435,
    SEASHELL4 = 436,
    BEET = 437,
    TEAL = 438,
    SIENNA = 439,
    SIENNA1 = 440,
    SIENNA2 = 441,
    SIENNA3 = 442,
    SIENNA4 = 443,
    SKYBLUE = 444,
    SKYBLUE1 = 445,
    SKYBLUE2 = 446,
    SKYBLUE3 = 447,
    SKYBLUE4 = 448,
    SLATEBLUE = 449,
    SLATEBLUE1 = 450,
    SLATEBLUE2 = 451,
    SLATEBLUE3 = 452,
    SLATEBLUE4 = 453,
    SLATEGRAY1 = 454,
    SLATEGRAY2 = 455,
    SLATEGRAY3 = 456,
    SLATEGRAY4 = 457,
    SLATEGRAY = 458,
    SNOW = 459,
    SNOW2 = 460,
    SNOW3 = 461,
    SNOW4 = 462,
    SPRINGGREEN = 463,
    SPRINGGREEN2 = 464,
    SPRINGGREEN3 = 465,
    SPRINGGREEN4 = 466,
    STEELBLUE = 467,
    STEELBLUE1 = 468,
    STEELBLUE2 = 469,
    STEELBLUE3 = 470,
    STEELBLUE4 = 471,
    TAN = 472,
    TAN1 = 473,
    TAN2 = 474,
    TAN3 = 475,
    TAN4 = 476,
    THISTLE = 477,
    THISTLE1 = 478,
    THISTLE2 = 479,
    THISTLE3 = 480,
    THISTLE4 = 481,
    TOMATO = 482,
    TOMATO1 = 482,
    TOMATO2 = 483,
    TOMATO3 = 484,
    TOMATO4 = 485,
    TURQUOISE = 486,
    TURQUOISE1 = 487,
    TURQUOISE2 = 488,
    TURQUOISE3 = 489,
    TURQUOISE4 = 490,
    VIOLET = 491,
    VIOLETRED = 492,
    VIOLETRED1 = 493,
    VIOLETRED2 = 494,
    VIOLETRED3 = 495,
    VIOLETRED4 = 496,
    WHEAT = 497,
    WHEAT1 = 498,
    WHEAT2 = 499,
    WHEAT3 = 500,
    WHEAT4 = 501,
    WHITESMOKE = 502,
    YELLOW = 503,
    YELLOW1 = 503,
    YELLOW2 = 504,
    YELLOW3 = 505,
    YELLOW4 = 506,
    YELLOWGREEN = 507,
    WHITE = 508
}; // enum  class Quantity_NameOfColor

//---------------------------------------------------------------------
//  Enum  Quantity_TypeOfColor
//---------------------------------------------------------------------
/// <summary>
/// Identifies color definition systems.
/// </summary>
public enum class Quantity_TypeOfColor
{
    RGB = 0,
    sRGB = 1,
    HLS = 2,
    CIELab = 3,
    CIELch = 4
}; // enum  class Quantity_TypeOfColor

//---------------------------------------------------------------------
//  Class  Quantity_Array1OfColor
//---------------------------------------------------------------------
public ref class Quantity_Array1OfColor sealed
    : public Macad::Occt::BaseClass<::Quantity_Array1OfColor>
    , public IIndexEnumerable<Macad::Occt::Quantity_Color^>
{

#ifdef Include_Quantity_Array1OfColor_h
public:
    Include_Quantity_Array1OfColor_h
#endif

public:
    Quantity_Array1OfColor(::Quantity_Array1OfColor* nativeInstance)
        : Macad::Occt::BaseClass<::Quantity_Array1OfColor>( nativeInstance, true )
    {}

    Quantity_Array1OfColor(::Quantity_Array1OfColor& nativeInstance)
        : Macad::Occt::BaseClass<::Quantity_Array1OfColor>( &nativeInstance, false )
    {}

    property ::Quantity_Array1OfColor* NativeInstance
    {
        ::Quantity_Array1OfColor* get()
        {
            return static_cast<::Quantity_Array1OfColor*>(_NativeInstance);
        }
    }

public:
    ref class Iterator sealed
        : public Macad::Occt::BaseClass<::Quantity_Array1OfColor::Iterator>
    {

#ifdef Include_Quantity_Array1OfColor_Iterator_h
    public:
        Include_Quantity_Array1OfColor_Iterator_h
#endif

    public:
        Iterator(::Quantity_Array1OfColor::Iterator* nativeInstance)
            : Macad::Occt::BaseClass<::Quantity_Array1OfColor::Iterator>( nativeInstance, true )
        {}

        Iterator(::Quantity_Array1OfColor::Iterator& nativeInstance)
            : Macad::Occt::BaseClass<::Quantity_Array1OfColor::Iterator>( &nativeInstance, false )
        {}

        property ::Quantity_Array1OfColor::Iterator* NativeInstance
        {
            ::Quantity_Array1OfColor::Iterator* get()
            {
                return static_cast<::Quantity_Array1OfColor::Iterator*>(_NativeInstance);
            }
        }

    public:
        void Init(Macad::Occt::Quantity_Array1OfColor^ theList);
        bool More();
        void Initialize(Macad::Occt::Quantity_Array1OfColor^ theList);
        /* Method skipped due to unknown mapping: iterator ValueIter() */
        /* Method skipped due to unknown mapping: iterator ChangeValueIter() */
        /* Method skipped due to unknown mapping: iterator EndIter() */
        /* Method skipped due to unknown mapping: iterator ChangeEndIter() */
        void Next();
        Macad::Occt::Quantity_Color^ Value();
        Macad::Occt::Quantity_Color^ ChangeValue();
    }; // class Iterator

    Quantity_Array1OfColor();
    Quantity_Array1OfColor(int theLower, int theUpper);
    /* Method skipped due to unknown mapping: void Quantity_Array1OfColor(allocator_type theAlloc, int theLower, int theUpper, ) */
    Quantity_Array1OfColor(Macad::Occt::Quantity_Color^ theBegin, int theLower, int theUpper, bool theUseBuffer);
    Quantity_Array1OfColor(Macad::Occt::Quantity_Color^ theBegin, int theLower, int theUpper);
    void Init(Macad::Occt::Quantity_Color^ theValue);
    int Size();
    int Length();
    bool IsEmpty();
    int Lower();
    int Upper();
    Macad::Occt::Quantity_Array1OfColor^ Assign(Macad::Occt::Quantity_Array1OfColor^ theOther);
    Macad::Occt::Quantity_Array1OfColor^ Move(Macad::Occt::Quantity_Array1OfColor^ theOther);
    Macad::Occt::Quantity_Color^ First();
    Macad::Occt::Quantity_Color^ ChangeFirst();
    Macad::Occt::Quantity_Color^ Last();
    Macad::Occt::Quantity_Color^ ChangeLast();
    virtual Macad::Occt::Quantity_Color^ Value(int theIndex);
    Macad::Occt::Quantity_Color^ ChangeValue(int theIndex);
    void SetValue(int theIndex, Macad::Occt::Quantity_Color^ theItem);
    void UpdateLowerBound(int theLower);
    void UpdateUpperBound(int theUpper);
    void Resize(int theLower, int theUpper, bool theToCopyData);
    bool IsDeletable();
    virtual System::Collections::Generic::IEnumerator<Macad::Occt::Quantity_Color^>^ GetEnumerator();
    virtual System::Collections::IEnumerator^ GetEnumerator2() = System::Collections::IEnumerable::GetEnumerator;
}; // class Quantity_Array1OfColor

//---------------------------------------------------------------------
//  Class  Quantity_Color
//---------------------------------------------------------------------
/// <summary>
/// This class allows the definition of an RGB color as triplet of 3 normalized floating point
/// values (red, green, blue).
/// 
/// Although Quantity_Color can be technically used for pass-through storage of RGB triplet in any
/// color space, other OCCT interfaces taking/returning Quantity_Color would expect them in linear
/// space. Therefore, take a look into methods converting to and from non-linear sRGB color space,
/// if needed; for instance, application usually providing color picking within 0..255 range in sRGB
/// color space.
/// </summary>
public ref class Quantity_Color sealed
    : public Macad::Occt::BaseClass<::Quantity_Color>
{

#ifdef Include_Quantity_Color_h
public:
    Include_Quantity_Color_h
#endif

public:
    Quantity_Color(::Quantity_Color* nativeInstance)
        : Macad::Occt::BaseClass<::Quantity_Color>( nativeInstance, true )
    {}

    Quantity_Color(::Quantity_Color& nativeInstance)
        : Macad::Occt::BaseClass<::Quantity_Color>( &nativeInstance, false )
    {}

    property ::Quantity_Color* NativeInstance
    {
        ::Quantity_Color* get()
        {
            return static_cast<::Quantity_Color*>(_NativeInstance);
        }
    }

public:
    /// <summary>
    /// Creates Quantity_NOC_YELLOW color (for historical reasons).
    /// </summary>
    Quantity_Color();
    /// <summary>
    /// Creates the color from enumeration value.
    /// </summary>
    Quantity_Color(Macad::Occt::Quantity_NameOfColor theName);
    /// <summary>
    /// Creates a color according to the definition system theType.
    /// Throws exception if values are out of range.
    /// </summary>
    Quantity_Color(double theC1, double theC2, double theC3, Macad::Occt::Quantity_TypeOfColor theType);
    /// <summary>
    /// Define color from linear RGB values.
    /// </summary>
    Quantity_Color(Macad::Occt::gp_Vec3f^ theRgb);
    /// <summary>
    /// Returns the name of the nearest color from the Quantity_NameOfColor enumeration.
    /// </summary>
    Macad::Occt::Quantity_NameOfColor Name();
    /// <summary>
    /// Updates the color from specified named color.
    /// </summary>
    void SetValues(Macad::Occt::Quantity_NameOfColor theName);
    /// <summary>
    /// Return the color as vector of 3 float elements.
    /// </summary>
    Macad::Occt::gp_Vec3f^ Rgb();
    /// <summary>
    /// Returns in theC1, theC2 and theC3 the components of this color
    /// according to the color system definition theType.
    /// </summary>
    void Values(double% theC1, double% theC2, double% theC3, Macad::Occt::Quantity_TypeOfColor theType);
    /// <summary>
    /// Updates a color according to the mode specified by theType.
    /// Throws exception if values are out of range.
    /// </summary>
    void SetValues(double theC1, double theC2, double theC3, Macad::Occt::Quantity_TypeOfColor theType);
    /// <summary>
    /// Returns the Red component (quantity of red) of the color within range [0.0; 1.0].
    /// </summary>
    double Red();
    /// <summary>
    /// Returns the Green component (quantity of green) of the color within range [0.0; 1.0].
    /// </summary>
    double Green();
    /// <summary>
    /// Returns the Blue component (quantity of blue) of the color within range [0.0; 1.0].
    /// </summary>
    double Blue();
    /// <summary>
    /// Returns the Hue component (hue angle) of the color
    /// in degrees within range [0.0; 360.0], 0.0 being Red.
    /// -1.0 is a special value reserved for grayscale color (S should be 0.0)
    /// </summary>
    double Hue();
    /// <summary>
    /// Returns the Light component (value of the lightness) of the color within range [0.0; 1.0].
    /// </summary>
    double Light();
    /// <summary>
    /// Increases or decreases the intensity (variation of the lightness).
    /// The delta is a percentage. Any value greater than zero will increase the intensity.
    /// The variation is expressed as a percentage of the current value.
    /// </summary>
    void ChangeIntensity(double theDelta);
    /// <summary>
    /// Returns the Saturation component (value of the saturation) of the color within range
    /// [0.0; 1.0].
    /// </summary>
    double Saturation();
    /// <summary>
    /// Increases or decreases the contrast (variation of the saturation).
    /// The delta is a percentage. Any value greater than zero will increase the contrast.
    /// The variation is expressed as a percentage of the current value.
    /// </summary>
    void ChangeContrast(double theDelta);
    /// <summary>
    /// Returns TRUE if the distance between two colors is greater than Epsilon().
    /// </summary>
    bool IsDifferent(Macad::Occt::Quantity_Color^ theOther);
    /// <summary>
    /// Returns TRUE if the distance between two colors is no greater than Epsilon().
    /// </summary>
    bool IsEqual(Macad::Occt::Quantity_Color^ theOther);
    /// <summary>
    /// Returns the distance between two colors. It's a value between 0 and the square root of 3 (the
    /// black/white distance).
    /// </summary>
    double Distance(Macad::Occt::Quantity_Color^ theColor);
    /// <summary>
    /// Returns the square of distance between two colors.
    /// </summary>
    double SquareDistance(Macad::Occt::Quantity_Color^ theColor);
    /// <summary>
    /// Returns the percentage change of contrast and intensity between this and another color.
    /// <DC> and <DI> are percentages, either positive or negative.
    /// The calculation is with respect to this color.
    /// If <DC> is positive then <me> is more contrasty.
    /// If <DI> is positive then <me> is more intense.
    /// </summary>
    void Delta(Macad::Occt::Quantity_Color^ theColor, double% DC, double% DI);
    /// <summary>
    /// Returns the value of the perceptual difference between this color
    /// and @p theOther, computed using the CIEDE2000 formula.
    /// The difference is in range [0, 100.], with 1 approximately corresponding
    /// to the minimal perceivable difference (usually difference 5 or greater is
    /// needed for the difference to be recognizable in practice).
    /// </summary>
    double DeltaE2000(Macad::Occt::Quantity_Color^ theOther);
    /// <summary>
    /// Returns the color from Quantity_NameOfColor enumeration nearest to specified RGB values.
    /// </summary>
    static Macad::Occt::Quantity_NameOfColor Name(double theR, double theG, double theB);
    /// <summary>
    /// Returns the name of the color identified by the given Quantity_NameOfColor enumeration value.
    /// </summary>
    static System::String^ StringName(Macad::Occt::Quantity_NameOfColor theColor);
    /// <summary>
    /// Finds color from predefined names.
    /// For example, the name of the color which corresponds to "BLACK" is Quantity_NOC_BLACK.
    /// Returns FALSE if name is unknown.
    /// </summary>
    static bool ColorFromName(System::String^ theName, Macad::Occt::Quantity_NameOfColor% theColor);
    /// <summary>
    /// Finds color from predefined names.
    /// </summary>
    /// <param name="theColorNameString">
    /// the color name
    /// </param>
    /// <param name="theColor">
    /// a found color
    /// </param>
    /// <returns>
    /// false if the color name is unknown, or true if the search by color name was successful
    /// </returns>
    static bool ColorFromName(System::String^ theColorNameString, Macad::Occt::Quantity_Color^ theColor);
    /// <summary>
    /// Parses the string as a hex color (like "#FF0" for short sRGB color, or "#FFFF00" for sRGB
    /// color)
    /// </summary>
    /// <param name="theHexColorString">
    /// the string to be parsed
    /// </param>
    /// <param name="theColor">
    /// a color that is a result of parsing
    /// </param>
    /// <returns>
    /// true if parsing was successful, or false otherwise
    /// </returns>
    static bool ColorFromHex(System::String^ theHexColorString, Macad::Occt::Quantity_Color^ theColor);
    /// <summary>
    /// Returns hex sRGB string in format "#FFAAFF".
    /// </summary>
    static Macad::Occt::TCollection_AsciiString^ ColorToHex(Macad::Occt::Quantity_Color^ theColor, bool theToPrefixHash);
    /// <summary>
    /// Returns hex sRGB string in format "#FFAAFF".
    /// </summary>
    static Macad::Occt::TCollection_AsciiString^ ColorToHex(Macad::Occt::Quantity_Color^ theColor);
    /// <summary>
    /// Converts sRGB components into HLS ones.
    /// </summary>
    static Macad::Occt::gp_Vec3f^ Convert_sRGB_To_HLS(Macad::Occt::gp_Vec3f^ theRgb);
    /// <summary>
    /// Converts HLS components into RGB ones.
    /// </summary>
    static Macad::Occt::gp_Vec3f^ Convert_HLS_To_sRGB(Macad::Occt::gp_Vec3f^ theHls);
    /// <summary>
    /// Converts Linear RGB components into HLS ones.
    /// </summary>
    static Macad::Occt::gp_Vec3f^ Convert_LinearRGB_To_HLS(Macad::Occt::gp_Vec3f^ theRgb);
    /// <summary>
    /// Converts HLS components into linear RGB ones.
    /// </summary>
    static Macad::Occt::gp_Vec3f^ Convert_HLS_To_LinearRGB(Macad::Occt::gp_Vec3f^ theHls);
    /// <summary>
    /// Converts linear RGB components into CIE Lab ones.
    /// </summary>
    static Macad::Occt::gp_Vec3f^ Convert_LinearRGB_To_Lab(Macad::Occt::gp_Vec3f^ theRgb);
    /// <summary>
    /// Converts CIE Lab components into CIE Lch ones.
    /// </summary>
    static Macad::Occt::gp_Vec3f^ Convert_Lab_To_Lch(Macad::Occt::gp_Vec3f^ theLab);
    /// <summary>
    /// Converts CIE Lab components into linear RGB ones.
    /// Note that the resulting values may be out of the valid range for RGB.
    /// </summary>
    static Macad::Occt::gp_Vec3f^ Convert_Lab_To_LinearRGB(Macad::Occt::gp_Vec3f^ theLab);
    /// <summary>
    /// Converts CIE Lch components into CIE Lab ones.
    /// </summary>
    static Macad::Occt::gp_Vec3f^ Convert_Lch_To_Lab(Macad::Occt::gp_Vec3f^ theLch);
    /// <summary>
    /// Convert the color value to ARGB integer value, with alpha equals to 0.
    /// So the output is formatted as 0x00RRGGBB.
    /// Note that this unpacking does NOT involve non-linear sRGB -> linear RGB conversion,
    /// as would be usually expected for RGB color packed into 4 bytes.
    /// </summary>
    /// <param name="in]">
    /// theColor  color to convert
    /// </param>
    /// <param name="out]">
    /// theARGB  result color encoded as integer
    /// </param>
    static void Color2argb(Macad::Occt::Quantity_Color^ theColor, int% theARGB);
    /// <summary>
    /// Convert integer ARGB value to Color. Alpha bits are ignored.
    /// Note that this packing does NOT involve linear -> non-linear sRGB conversion,
    /// as would be usually expected to preserve higher (for human eye) color precision in 4 bytes.
    /// </summary>
    static void Argb2color(int theARGB, Macad::Occt::Quantity_Color^ theColor);
    /// <summary>
    /// Convert linear RGB component into sRGB using OpenGL specs formula (double precision), also
    /// known as gamma correction.
    /// </summary>
    static double Convert_LinearRGB_To_sRGB(double theLinearValue);
    /// <summary>
    /// Convert linear RGB component into sRGB using OpenGL specs formula (single precision), also
    /// known as gamma correction.
    /// </summary>
    static float Convert_LinearRGB_To_sRGB(float theLinearValue);
    /// <summary>
    /// Convert sRGB component into linear RGB using OpenGL specs formula (double precision), also
    /// known as gamma correction.
    /// </summary>
    static double Convert_sRGB_To_LinearRGB(double thesRGBValue);
    /// <summary>
    /// Convert sRGB component into linear RGB using OpenGL specs formula (single precision), also
    /// known as gamma correction.
    /// </summary>
    static float Convert_sRGB_To_LinearRGB(float thesRGBValue);
    static Macad::Occt::gp_Vec3f^ Convert_LinearRGB_To_sRGB(Macad::Occt::gp_Vec3f^ theRGB);
    static Macad::Occt::gp_Vec3f^ Convert_sRGB_To_LinearRGB(Macad::Occt::gp_Vec3f^ theRGB);
    /// <summary>
    /// Convert linear RGB component into sRGB using approximated uniform gamma coefficient 2.2.
    /// </summary>
    static float Convert_LinearRGB_To_sRGB_approx22(float theLinearValue);
    /// <summary>
    /// Convert sRGB component into linear RGB using approximated uniform gamma coefficient 2.2
    /// </summary>
    static float Convert_sRGB_To_LinearRGB_approx22(float thesRGBValue);
    /// <summary>
    /// Convert linear RGB components into sRGB using approximated uniform gamma coefficient 2.2
    /// </summary>
    static Macad::Occt::gp_Vec3f^ Convert_LinearRGB_To_sRGB_approx22(Macad::Occt::gp_Vec3f^ theRGB);
    /// <summary>
    /// Convert sRGB components into linear RGB using approximated uniform gamma coefficient 2.2
    /// </summary>
    static Macad::Occt::gp_Vec3f^ Convert_sRGB_To_LinearRGB_approx22(Macad::Occt::gp_Vec3f^ theRGB);
    /// <summary>
    /// Converts HLS components into sRGB ones.
    /// </summary>
    static void HlsRgb(double theH, double theL, double theS, double% theR, double% theG, double% theB);
    /// <summary>
    /// Converts sRGB components into HLS ones.
    /// </summary>
    static void RgbHls(double theR, double theG, double theB, double% theH, double% theL, double% theS);
    /// <summary>
    /// Returns the value used to compare two colors for equality; 0.0001 by default.
    /// </summary>
    static double Epsilon();
    /// <summary>
    /// Set the value used to compare two colors for equality.
    /// </summary>
    static void SetEpsilon(double theEpsilon);
    /// <summary>
    /// Dumps the content of me into the stream
    /// </summary>
    void DumpJson(System::IO::TextWriter^ theOStream, int theDepth);
    /// <summary>
    /// Dumps the content of me into the stream
    /// </summary>
    void DumpJson(System::IO::TextWriter^ theOStream);
    /* Method skipped due to unknown mapping: bool InitFromJson(stringstream theSStream, int theStreamPos, ) */
    bool Equals(System::Object^ obj) override;
    int GetHashCode() override;
}; // class Quantity_Color

//---------------------------------------------------------------------
//  Class  Quantity_ColorRGBA
//---------------------------------------------------------------------
/// <summary>
/// The pair of Quantity_Color and Alpha component (1.0 opaque, 0.0 transparent).
/// </summary>
public ref class Quantity_ColorRGBA sealed
    : public Macad::Occt::BaseClass<::Quantity_ColorRGBA>
{

#ifdef Include_Quantity_ColorRGBA_h
public:
    Include_Quantity_ColorRGBA_h
#endif

public:
    Quantity_ColorRGBA(::Quantity_ColorRGBA* nativeInstance)
        : Macad::Occt::BaseClass<::Quantity_ColorRGBA>( nativeInstance, true )
    {}

    Quantity_ColorRGBA(::Quantity_ColorRGBA& nativeInstance)
        : Macad::Occt::BaseClass<::Quantity_ColorRGBA>( &nativeInstance, false )
    {}

    property ::Quantity_ColorRGBA* NativeInstance
    {
        ::Quantity_ColorRGBA* get()
        {
            return static_cast<::Quantity_ColorRGBA*>(_NativeInstance);
        }
    }

public:
    /// <summary>
    /// Creates a color with the default value.
    /// </summary>
    Quantity_ColorRGBA();
    /// <summary>
    /// Creates the color with specified RGB value.
    /// </summary>
    Quantity_ColorRGBA(Macad::Occt::Quantity_Color^ theRgb);
    /// <summary>
    /// Creates the color with specified RGBA values.
    /// </summary>
    Quantity_ColorRGBA(Macad::Occt::Quantity_Color^ theRgb, float theAlpha);
    /// <summary>
    /// Creates the color from RGBA vector.
    /// </summary>
    Quantity_ColorRGBA(Macad::Occt::Graphic3d_Vec4^ theRgba);
    /// <summary>
    /// Creates the color from RGBA values.
    /// </summary>
    Quantity_ColorRGBA(float theRed, float theGreen, float theBlue, float theAlpha);
    /// <summary>
    /// Assign new values to the color.
    /// </summary>
    void SetValues(float theRed, float theGreen, float theBlue, float theAlpha);
    /// <summary>
    /// Return RGB color value.
    /// </summary>
    Macad::Occt::Quantity_Color^ GetRGB();
    /// <summary>
    /// Modify RGB color components without affecting alpha value.
    /// </summary>
    Macad::Occt::Quantity_Color^ ChangeRGB();
    /// <summary>
    /// Assign RGB color components without affecting alpha value.
    /// </summary>
    void SetRGB(Macad::Occt::Quantity_Color^ theRgb);
    /// <summary>
    /// Return alpha value (1.0 means opaque, 0.0 means fully transparent).
    /// </summary>
    float Alpha();
    /// <summary>
    /// Assign the alpha value.
    /// </summary>
    void SetAlpha(float theAlpha);
    /// <summary>
    /// Returns true if the distance between colors is greater than Epsilon().
    /// </summary>
    bool IsDifferent(Macad::Occt::Quantity_ColorRGBA^ theOther);
    /// <summary>
    /// Two colors are considered to be equal if their distance is no greater than Epsilon().
    /// </summary>
    bool IsEqual(Macad::Occt::Quantity_ColorRGBA^ theOther);
    /// <summary>
    /// Finds color from predefined names.
    /// For example, the name of the color which corresponds to "BLACK" is Quantity_NOC_BLACK.
    /// An alpha component is set to 1.0.
    /// </summary>
    /// <param name="theColorNameString">
    /// the color name
    /// </param>
    /// <param name="theColor">
    /// a found color
    /// </param>
    /// <returns>
    /// false if the color name is unknown, or true if the search by color name was successful
    /// </returns>
    static bool ColorFromName(System::String^ theColorNameString, Macad::Occt::Quantity_ColorRGBA^ theColor);
    /// <summary>
    /// Parses the string as a hex color (like "#FF0" for short sRGB color, "#FF0F" for short sRGBA
    /// color,
    /// "#FFFF00" for RGB color, or "#FFFF00FF" for RGBA color)
    /// </summary>
    /// <param name="theHexColorString">
    /// the string to be parsed
    /// </param>
    /// <param name="theColor">
    /// a color that is a result of parsing
    /// </param>
    /// <param name="theAlphaComponentIsOff">
    /// the flag that indicates if a color alpha component is presented
    /// in the input string (false) or not (true)
    /// </param>
    /// <returns>
    /// true if parsing was successful, or false otherwise
    /// </returns>
    static bool ColorFromHex(char theHexColorString, Macad::Occt::Quantity_ColorRGBA^ theColor, bool theAlphaComponentIsOff);
    /// <summary>
    /// Parses the string as a hex color (like "#FF0" for short sRGB color, "#FF0F" for short sRGBA
    /// color,
    /// "#FFFF00" for RGB color, or "#FFFF00FF" for RGBA color)
    /// </summary>
    /// <param name="theHexColorString">
    /// the string to be parsed
    /// </param>
    /// <param name="theColor">
    /// a color that is a result of parsing
    /// </param>
    /// <param name="theAlphaComponentIsOff">
    /// the flag that indicates if a color alpha component is presented
    /// in the input string (false) or not (true)
    /// </param>
    /// <returns>
    /// true if parsing was successful, or false otherwise
    /// </returns>
    static bool ColorFromHex(char theHexColorString, Macad::Occt::Quantity_ColorRGBA^ theColor);
    /// <summary>
    /// Returns hex sRGBA string in format "#RRGGBBAA".
    /// </summary>
    static Macad::Occt::TCollection_AsciiString^ ColorToHex(Macad::Occt::Quantity_ColorRGBA^ theColor, bool theToPrefixHash);
    /// <summary>
    /// Returns hex sRGBA string in format "#RRGGBBAA".
    /// </summary>
    static Macad::Occt::TCollection_AsciiString^ ColorToHex(Macad::Occt::Quantity_ColorRGBA^ theColor);
    /// <summary>
    /// Convert linear RGB components into sRGB using OpenGL specs formula.
    /// </summary>
    static Macad::Occt::Graphic3d_Vec4^ Convert_LinearRGB_To_sRGB(Macad::Occt::Graphic3d_Vec4^ theRGB);
    /// <summary>
    /// Convert sRGB components into linear RGB using OpenGL specs formula.
    /// </summary>
    static Macad::Occt::Graphic3d_Vec4^ Convert_sRGB_To_LinearRGB(Macad::Occt::Graphic3d_Vec4^ theRGB);
    /// <summary>
    /// Dumps the content of me into the stream
    /// </summary>
    void DumpJson(System::IO::TextWriter^ theOStream, int theDepth);
    /// <summary>
    /// Dumps the content of me into the stream
    /// </summary>
    void DumpJson(System::IO::TextWriter^ theOStream);
    /* Method skipped due to unknown mapping: bool InitFromJson(stringstream theSStream, int theStreamPos, ) */
    bool Equals(System::Object^ obj) override;
    int GetHashCode() override;
}; // class Quantity_ColorRGBA

//---------------------------------------------------------------------
//  Class  Quantity_Period
//---------------------------------------------------------------------
/// <summary>
/// Manages date intervals. For example, a Period object
/// gives the interval between two dates.
/// A period is expressed in seconds and microseconds.
/// </summary>
public ref class Quantity_Period sealed
    : public Macad::Occt::BaseClass<::Quantity_Period>
{

#ifdef Include_Quantity_Period_h
public:
    Include_Quantity_Period_h
#endif

public:
    Quantity_Period(::Quantity_Period* nativeInstance)
        : Macad::Occt::BaseClass<::Quantity_Period>( nativeInstance, true )
    {}

    Quantity_Period(::Quantity_Period& nativeInstance)
        : Macad::Occt::BaseClass<::Quantity_Period>( &nativeInstance, false )
    {}

    property ::Quantity_Period* NativeInstance
    {
        ::Quantity_Period* get()
        {
            return static_cast<::Quantity_Period*>(_NativeInstance);
        }
    }

public:
    /// <summary>
    /// Creates a Period
    /// With:      0 <= dd
    /// 0 <= hh
    /// 0 <= mn
    /// 0 <= ss
    /// 0 <= mis
    /// 0 <= mics
    /// </summary>
    Quantity_Period(int dd, int hh, int mn, int ss, int mis, int mics);
    /// <summary>
    /// Creates a Period
    /// With:      0 <= dd
    /// 0 <= hh
    /// 0 <= mn
    /// 0 <= ss
    /// 0 <= mis
    /// 0 <= mics
    /// </summary>
    Quantity_Period(int dd, int hh, int mn, int ss, int mis);
    /// <summary>
    /// Creates a Period
    /// With:      0 <= dd
    /// 0 <= hh
    /// 0 <= mn
    /// 0 <= ss
    /// 0 <= mis
    /// 0 <= mics
    /// </summary>
    Quantity_Period(int dd, int hh, int mn, int ss);
    /// <summary>
    /// Creates a Period with a number of seconds and microseconds.
    /// Exceptions
    /// Quantity_PeriodDefinitionError:
    /// -   if the number of seconds expressed either by:
    /// -   dd days, hh hours, mn minutes and ss seconds, or
    /// -   Ss
    /// is less than 0.
    /// -   if the number of microseconds expressed either by:
    /// -   mis milliseconds and mics microseconds, or
    /// -   Mics
    /// is less than 0.
    /// </summary>
    Quantity_Period(int ss, int mics);
    /// <summary>
    /// Creates a Period with a number of seconds and microseconds.
    /// Exceptions
    /// Quantity_PeriodDefinitionError:
    /// -   if the number of seconds expressed either by:
    /// -   dd days, hh hours, mn minutes and ss seconds, or
    /// -   Ss
    /// is less than 0.
    /// -   if the number of microseconds expressed either by:
    /// -   mis milliseconds and mics microseconds, or
    /// -   Mics
    /// is less than 0.
    /// </summary>
    Quantity_Period(int ss);
    /// <summary>
    /// Decomposes this period into a number of days,hours,
    /// minutes,seconds,milliseconds and microseconds
    /// Example of return values:
    /// 2 days, 15 hours, 0 minute , 0 second
    /// 0 millisecond and 0 microsecond
    /// </summary>
    void Values(int% dd, int% hh, int% mn, int% ss, int% mis, int% mics);
    /// <summary>
    /// Returns the number of seconds in Ss and the
    /// number of remainding microseconds in Mics of this period.
    /// Example of return values: 3600 seconds and 0 microseconds
    /// </summary>
    void Values(int% ss, int% mics);
    /// <summary>
    /// Assigns to this period the time interval defined
    /// -   with dd days, hh hours, mn minutes, ss
    /// seconds, mis (defaulted to 0) milliseconds and
    /// mics (defaulted to 0) microseconds; or
    /// </summary>
    void SetValues(int dd, int hh, int mn, int ss, int mis, int mics);
    /// <summary>
    /// Assigns to this period the time interval defined
    /// -   with dd days, hh hours, mn minutes, ss
    /// seconds, mis (defaulted to 0) milliseconds and
    /// mics (defaulted to 0) microseconds; or
    /// </summary>
    void SetValues(int dd, int hh, int mn, int ss, int mis);
    /// <summary>
    /// Assigns to this period the time interval defined
    /// -   with dd days, hh hours, mn minutes, ss
    /// seconds, mis (defaulted to 0) milliseconds and
    /// mics (defaulted to 0) microseconds; or
    /// </summary>
    void SetValues(int dd, int hh, int mn, int ss);
    /// <summary>
    /// Assigns to this period the time interval defined
    /// -   with Ss seconds and Mics (defaulted to 0) microseconds.
    /// Exceptions
    /// Quantity_PeriodDefinitionError:
    /// -   if the number of seconds expressed either by:
    /// -   dd days, hh hours, mn minutes and ss seconds, or
    /// -   Ss
    /// is less than 0.
    /// -   if the number of microseconds expressed either by:
    /// -   mis milliseconds and mics microseconds, or
    /// -   Mics
    /// is less than 0.
    /// </summary>
    void SetValues(int ss, int mics);
    /// <summary>
    /// Assigns to this period the time interval defined
    /// -   with Ss seconds and Mics (defaulted to 0) microseconds.
    /// Exceptions
    /// Quantity_PeriodDefinitionError:
    /// -   if the number of seconds expressed either by:
    /// -   dd days, hh hours, mn minutes and ss seconds, or
    /// -   Ss
    /// is less than 0.
    /// -   if the number of microseconds expressed either by:
    /// -   mis milliseconds and mics microseconds, or
    /// -   Mics
    /// is less than 0.
    /// </summary>
    void SetValues(int ss);
    /// <summary>
    /// Subtracts one Period from another and returns the difference.
    /// </summary>
    Macad::Occt::Quantity_Period^ Subtract(Macad::Occt::Quantity_Period^ anOther);
    /// <summary>
    /// Adds one Period to another one.
    /// </summary>
    Macad::Occt::Quantity_Period^ Add(Macad::Occt::Quantity_Period^ anOther);
    /// <summary>
    /// Returns TRUE if both <me> and <other> are equal.
    /// </summary>
    bool IsEqual(Macad::Occt::Quantity_Period^ anOther);
    /// <summary>
    /// Returns TRUE if <me> is shorter than <other>.
    /// </summary>
    bool IsShorter(Macad::Occt::Quantity_Period^ anOther);
    /// <summary>
    /// Returns TRUE if <me> is longer then <other>.
    /// </summary>
    bool IsLonger(Macad::Occt::Quantity_Period^ anOther);
    /// <summary>
    /// Checks the validity of a Period in form (dd,hh,mn,ss,mil,mic)
    /// With:      0 <= dd
    /// 0 <= hh
    /// 0 <= mn
    /// 0 <= ss
    /// 0 <= mis
    /// 0 <= mics
    /// </summary>
    static bool IsValid(int dd, int hh, int mn, int ss, int mis, int mics);
    /// <summary>
    /// Checks the validity of a Period in form (dd,hh,mn,ss,mil,mic)
    /// With:      0 <= dd
    /// 0 <= hh
    /// 0 <= mn
    /// 0 <= ss
    /// 0 <= mis
    /// 0 <= mics
    /// </summary>
    static bool IsValid(int dd, int hh, int mn, int ss, int mis);
    /// <summary>
    /// Checks the validity of a Period in form (dd,hh,mn,ss,mil,mic)
    /// With:      0 <= dd
    /// 0 <= hh
    /// 0 <= mn
    /// 0 <= ss
    /// 0 <= mis
    /// 0 <= mics
    /// </summary>
    static bool IsValid(int dd, int hh, int mn, int ss);
    /// <summary>
    /// Checks the validity of a Period in form (ss,mic)
    /// With:      0 <= ss
    /// 0 <= mics
    /// </summary>
    static bool IsValid(int ss, int mics);
    /// <summary>
    /// Checks the validity of a Period in form (ss,mic)
    /// With:      0 <= ss
    /// 0 <= mics
    /// </summary>
    static bool IsValid(int ss);
    bool Equals(System::Object^ obj) override;
}; // class Quantity_Period

//---------------------------------------------------------------------
//  Class  Quantity_Date
//---------------------------------------------------------------------
/// <summary>
/// This class provides services to manage date information.
/// A date represents the following time intervals:
/// year, month, day, hour, minute, second,
/// millisecond and microsecond.
/// Current time is expressed in elapsed seconds
/// and microseconds beginning from 00:00 GMT,
/// January 1, 1979 (zero hour). The valid date can
/// only be later than this one.
/// Note: a Period object gives the interval between two dates.
/// </summary>
public ref class Quantity_Date sealed
    : public Macad::Occt::BaseClass<::Quantity_Date>
{

#ifdef Include_Quantity_Date_h
public:
    Include_Quantity_Date_h
#endif

public:
    Quantity_Date(::Quantity_Date* nativeInstance)
        : Macad::Occt::BaseClass<::Quantity_Date>( nativeInstance, true )
    {}

    Quantity_Date(::Quantity_Date& nativeInstance)
        : Macad::Occt::BaseClass<::Quantity_Date>( &nativeInstance, false )
    {}

    property ::Quantity_Date* NativeInstance
    {
        ::Quantity_Date* get()
        {
            return static_cast<::Quantity_Date*>(_NativeInstance);
        }
    }

public:
    /// <summary>
    /// Constructs a default date
    /// (00:00 GMT, January 1, 1979 (zero hour)); use the function
    /// SetValues to define the required date; or
    /// </summary>
    Quantity_Date();
    /// <summary>
    /// Constructs a date from the year yyyy, the
    /// month mm, the day dd, the hour hh, the minute
    /// mn, the second ss, the millisecond mis
    /// (defaulted to 0) and the microsecond mics (defaulted to 0)..
    /// With:      1 <= mm <= 12
    /// 1 <= dd <= max number of days of <mm>
    /// 1979 <= yyyy
    /// 0 <= hh <= 23
    /// 0 <= mn <= 59
    /// 0 <= ss <= 59
    /// 0 <= mis <= 999
    /// 0 <= mics <= 999
    /// Exceptions
    /// Quantity_DateDefinitionError if mm, dd, hh,
    /// mn, ss, mis and mics are not the components of the valid date.
    /// </summary>
    Quantity_Date(int mm, int dd, int yyyy, int hh, int mn, int ss, int mis, int mics);
    /// <summary>
    /// Constructs a date from the year yyyy, the
    /// month mm, the day dd, the hour hh, the minute
    /// mn, the second ss, the millisecond mis
    /// (defaulted to 0) and the microsecond mics (defaulted to 0)..
    /// With:      1 <= mm <= 12
    /// 1 <= dd <= max number of days of <mm>
    /// 1979 <= yyyy
    /// 0 <= hh <= 23
    /// 0 <= mn <= 59
    /// 0 <= ss <= 59
    /// 0 <= mis <= 999
    /// 0 <= mics <= 999
    /// Exceptions
    /// Quantity_DateDefinitionError if mm, dd, hh,
    /// mn, ss, mis and mics are not the components of the valid date.
    /// </summary>
    Quantity_Date(int mm, int dd, int yyyy, int hh, int mn, int ss, int mis);
    /// <summary>
    /// Constructs a date from the year yyyy, the
    /// month mm, the day dd, the hour hh, the minute
    /// mn, the second ss, the millisecond mis
    /// (defaulted to 0) and the microsecond mics (defaulted to 0)..
    /// With:      1 <= mm <= 12
    /// 1 <= dd <= max number of days of <mm>
    /// 1979 <= yyyy
    /// 0 <= hh <= 23
    /// 0 <= mn <= 59
    /// 0 <= ss <= 59
    /// 0 <= mis <= 999
    /// 0 <= mics <= 999
    /// Exceptions
    /// Quantity_DateDefinitionError if mm, dd, hh,
    /// mn, ss, mis and mics are not the components of the valid date.
    /// </summary>
    Quantity_Date(int mm, int dd, int yyyy, int hh, int mn, int ss);
    /// <summary>
    /// Gets a complete Date.
    /// -   in mm - the month,
    /// -   in dd - the day,
    /// -   in yyyy - the year,
    /// -   in hh - the hour,
    /// -   in mn - the minute,
    /// -   in ss - the second,
    /// -   in mis - the millisecond, and
    /// -   in mics - the microsecond
    /// </summary>
    void Values(int% mm, int% dd, int% yy, int% hh, int% mn, int% ss, int% mis, int% mics);
    /// <summary>
    /// Assigns to this date the year yyyy, the month
    /// mm, the day dd, the hour hh, the minute mn, the
    /// second ss, the millisecond mis (defaulted to 0)
    /// and the microsecond mics (defaulted to 0).
    /// Exceptions
    /// Quantity_DateDefinitionError if mm, dd, hh,
    /// mn, ss, mis and mics are not components of a valid date.
    /// </summary>
    void SetValues(int mm, int dd, int yy, int hh, int mn, int ss, int mis, int mics);
    /// <summary>
    /// Assigns to this date the year yyyy, the month
    /// mm, the day dd, the hour hh, the minute mn, the
    /// second ss, the millisecond mis (defaulted to 0)
    /// and the microsecond mics (defaulted to 0).
    /// Exceptions
    /// Quantity_DateDefinitionError if mm, dd, hh,
    /// mn, ss, mis and mics are not components of a valid date.
    /// </summary>
    void SetValues(int mm, int dd, int yy, int hh, int mn, int ss, int mis);
    /// <summary>
    /// Assigns to this date the year yyyy, the month
    /// mm, the day dd, the hour hh, the minute mn, the
    /// second ss, the millisecond mis (defaulted to 0)
    /// and the microsecond mics (defaulted to 0).
    /// Exceptions
    /// Quantity_DateDefinitionError if mm, dd, hh,
    /// mn, ss, mis and mics are not components of a valid date.
    /// </summary>
    void SetValues(int mm, int dd, int yy, int hh, int mn, int ss);
    /// <summary>
    /// Subtracts one Date from another one to find the period
    /// between and returns the value.
    /// The result is the absolute value between the difference
    /// of two dates.
    /// </summary>
    Macad::Occt::Quantity_Period^ Difference(Macad::Occt::Quantity_Date^ anOther);
    /// <summary>
    /// Subtracts a period from a Date and returns the new Date.
    /// Raises an exception if the result date is anterior to
    /// Jan 1, 1979.
    /// </summary>
    Macad::Occt::Quantity_Date^ Subtract(Macad::Occt::Quantity_Period^ aPeriod);
    /// <summary>
    /// Adds a Period to a Date and returns the new Date.
    /// </summary>
    Macad::Occt::Quantity_Date^ Add(Macad::Occt::Quantity_Period^ aPeriod);
    /// <summary>
    /// Returns year of a Date.
    /// </summary>
    int Year();
    /// <summary>
    /// Returns month of a Date.
    /// </summary>
    int Month();
    /// <summary>
    /// Returns Day of a Date.
    /// </summary>
    int Day();
    /// <summary>
    /// Returns Hour of a Date.
    /// </summary>
    int Hour();
    /// <summary>
    /// Returns minute of a Date.
    /// </summary>
    int Minute();
    /// <summary>
    /// Returns seconde of a Date.
    /// </summary>
    int Second();
    /// <summary>
    /// Returns millisecond of a Date.
    /// </summary>
    int MilliSecond();
    /// <summary>
    /// Returns microsecond of a Date.
    /// </summary>
    int MicroSecond();
    /// <summary>
    /// Returns TRUE if both <me> and <other> are equal.
    /// This method is an alias of operator ==.
    /// </summary>
    bool IsEqual(Macad::Occt::Quantity_Date^ anOther);
    /// <summary>
    /// Returns TRUE if <me> is earlier than <other>.
    /// </summary>
    bool IsEarlier(Macad::Occt::Quantity_Date^ anOther);
    /// <summary>
    /// Returns TRUE if <me> is later then <other>.
    /// </summary>
    bool IsLater(Macad::Occt::Quantity_Date^ anOther);
    /// <summary>
    /// Checks the validity of a date - returns true if a
    /// date defined from the year yyyy, the month mm,
    /// the day dd, the hour hh, the minute mn, the
    /// second ss, the millisecond mis (defaulted to 0)
    /// and the microsecond mics (defaulted to 0) is valid.
    /// A date must satisfy the conditions above:
    /// -   yyyy is greater than or equal to 1979,
    /// -   mm lies within the range [1, 12] (with 1
    /// corresponding to January and 12 to December),
    /// -   dd lies within a valid range for the month mm
    /// (from 1 to 28, 29, 30 or 31 depending on
    /// mm and whether yyyy is a leap year or not),
    /// -   hh lies within the range [0, 23],
    /// -   mn lies within the range [0, 59],
    /// -   ss lies within the range [0, 59],
    /// -   mis lies within the range [0, 999],
    /// -   mics lies within the range [0, 999].C
    /// </summary>
    static bool IsValid(int mm, int dd, int yy, int hh, int mn, int ss, int mis, int mics);
    /// <summary>
    /// Checks the validity of a date - returns true if a
    /// date defined from the year yyyy, the month mm,
    /// the day dd, the hour hh, the minute mn, the
    /// second ss, the millisecond mis (defaulted to 0)
    /// and the microsecond mics (defaulted to 0) is valid.
    /// A date must satisfy the conditions above:
    /// -   yyyy is greater than or equal to 1979,
    /// -   mm lies within the range [1, 12] (with 1
    /// corresponding to January and 12 to December),
    /// -   dd lies within a valid range for the month mm
    /// (from 1 to 28, 29, 30 or 31 depending on
    /// mm and whether yyyy is a leap year or not),
    /// -   hh lies within the range [0, 23],
    /// -   mn lies within the range [0, 59],
    /// -   ss lies within the range [0, 59],
    /// -   mis lies within the range [0, 999],
    /// -   mics lies within the range [0, 999].C
    /// </summary>
    static bool IsValid(int mm, int dd, int yy, int hh, int mn, int ss, int mis);
    /// <summary>
    /// Checks the validity of a date - returns true if a
    /// date defined from the year yyyy, the month mm,
    /// the day dd, the hour hh, the minute mn, the
    /// second ss, the millisecond mis (defaulted to 0)
    /// and the microsecond mics (defaulted to 0) is valid.
    /// A date must satisfy the conditions above:
    /// -   yyyy is greater than or equal to 1979,
    /// -   mm lies within the range [1, 12] (with 1
    /// corresponding to January and 12 to December),
    /// -   dd lies within a valid range for the month mm
    /// (from 1 to 28, 29, 30 or 31 depending on
    /// mm and whether yyyy is a leap year or not),
    /// -   hh lies within the range [0, 23],
    /// -   mn lies within the range [0, 59],
    /// -   ss lies within the range [0, 59],
    /// -   mis lies within the range [0, 999],
    /// -   mics lies within the range [0, 999].C
    /// </summary>
    static bool IsValid(int mm, int dd, int yy, int hh, int mn, int ss);
    /// <summary>
    /// Returns true if a year is a leap year.
    /// The leap years are divisible by 4 and not by 100 except
    /// the years divisible by 400.
    /// </summary>
    static bool IsLeap(int yy);
    bool Equals(System::Object^ obj) override;
}; // class Quantity_Date

//---------------------------------------------------------------------
//  Class  Quantity_DateDefinitionError
//---------------------------------------------------------------------
public ref class Quantity_DateDefinitionError sealed
    : public Macad::Occt::Standard_DomainError
{

#ifdef Include_Quantity_DateDefinitionError_h
public:
    Include_Quantity_DateDefinitionError_h
#endif

public:
    Quantity_DateDefinitionError(::Quantity_DateDefinitionError* nativeInstance)
        : Macad::Occt::Standard_DomainError( nativeInstance )
    {}

    Quantity_DateDefinitionError(::Quantity_DateDefinitionError& nativeInstance)
        : Macad::Occt::Standard_DomainError( nativeInstance )
    {}

    property ::Quantity_DateDefinitionError* NativeInstance
    {
        ::Quantity_DateDefinitionError* get()
        {
            return static_cast<::Quantity_DateDefinitionError*>(_NativeInstance);
        }
    }

public:
    Quantity_DateDefinitionError();
    Quantity_DateDefinitionError(System::String^ theMessage);
    Quantity_DateDefinitionError(System::String^ theMessage, System::String^ theStackTrace);
    static void Raise(System::String^ theMessage);
    static void Raise();
    /* Method skipped due to unknown mapping: void Raise(stringstream theMessage, ) */
    static Macad::Occt::Quantity_DateDefinitionError^ NewInstance(System::String^ theMessage);
    static Macad::Occt::Quantity_DateDefinitionError^ NewInstance();
    static Macad::Occt::Quantity_DateDefinitionError^ NewInstance(System::String^ theMessage, System::String^ theStackTrace);
    static Macad::Occt::Quantity_DateDefinitionError^ CreateDowncasted(::Quantity_DateDefinitionError* instance);
}; // class Quantity_DateDefinitionError

//---------------------------------------------------------------------
//  Class  Quantity_HArray1OfColor
//---------------------------------------------------------------------
public ref class Quantity_HArray1OfColor sealed
    : public Macad::Occt::Standard_Transient
    , public IIndexEnumerable<Macad::Occt::Quantity_Color^>
{

#ifdef Include_Quantity_HArray1OfColor_h
public:
    Include_Quantity_HArray1OfColor_h
#endif

public:
    Quantity_HArray1OfColor(::Quantity_HArray1OfColor* nativeInstance)
        : Macad::Occt::Standard_Transient( nativeInstance )
    {}

    Quantity_HArray1OfColor(::Quantity_HArray1OfColor& nativeInstance)
        : Macad::Occt::Standard_Transient( nativeInstance )
    {}

    property ::Quantity_HArray1OfColor* NativeInstance
    {
        ::Quantity_HArray1OfColor* get()
        {
            return static_cast<::Quantity_HArray1OfColor*>(_NativeInstance);
        }
    }

public:
    ref class Iterator sealed
        : public Macad::Occt::BaseClass<::Quantity_HArray1OfColor::Iterator>
    {

#ifdef Include_Quantity_HArray1OfColor_Iterator_h
    public:
        Include_Quantity_HArray1OfColor_Iterator_h
#endif

    public:
        Iterator(::Quantity_HArray1OfColor::Iterator* nativeInstance)
            : Macad::Occt::BaseClass<::Quantity_HArray1OfColor::Iterator>( nativeInstance, true )
        {}

        Iterator(::Quantity_HArray1OfColor::Iterator& nativeInstance)
            : Macad::Occt::BaseClass<::Quantity_HArray1OfColor::Iterator>( &nativeInstance, false )
        {}

        property ::Quantity_HArray1OfColor::Iterator* NativeInstance
        {
            ::Quantity_HArray1OfColor::Iterator* get()
            {
                return static_cast<::Quantity_HArray1OfColor::Iterator*>(_NativeInstance);
            }
        }

    public:
        void Init(Macad::Occt::Quantity_HArray1OfColor^ theList);
        bool More();
        void Initialize(Macad::Occt::Quantity_HArray1OfColor^ theList);
        /* Method skipped due to unknown mapping: iterator ValueIter() */
        /* Method skipped due to unknown mapping: iterator ChangeValueIter() */
        /* Method skipped due to unknown mapping: iterator EndIter() */
        /* Method skipped due to unknown mapping: iterator ChangeEndIter() */
        void Next();
        Macad::Occt::Quantity_Color^ Value();
        Macad::Occt::Quantity_Color^ ChangeValue();
    }; // class Iterator

    Quantity_HArray1OfColor();
    Quantity_HArray1OfColor(int theLower, int theUpper);
    Quantity_HArray1OfColor(int theLower, int theUpper, Macad::Occt::Quantity_Color^ theValue);
    Quantity_HArray1OfColor(Macad::Occt::Quantity_Color^ theBegin, int theLower, int theUpper, bool parameter1);
    Quantity_HArray1OfColor(Macad::Occt::Quantity_Array1OfColor^ theOther);
    Macad::Occt::Quantity_Array1OfColor^ Array1();
    Macad::Occt::Quantity_Array1OfColor^ ChangeArray1();
    void Init(Macad::Occt::Quantity_Color^ theValue);
    int Size();
    int Length();
    bool IsEmpty();
    int Lower();
    int Upper();
    Macad::Occt::Quantity_HArray1OfColor^ Assign(Macad::Occt::Quantity_HArray1OfColor^ theOther);
    Macad::Occt::Quantity_HArray1OfColor^ Move(Macad::Occt::Quantity_HArray1OfColor^ theOther);
    Macad::Occt::Quantity_Color^ First();
    Macad::Occt::Quantity_Color^ ChangeFirst();
    Macad::Occt::Quantity_Color^ Last();
    Macad::Occt::Quantity_Color^ ChangeLast();
    virtual Macad::Occt::Quantity_Color^ Value(int theIndex);
    Macad::Occt::Quantity_Color^ ChangeValue(int theIndex);
    void SetValue(int theIndex, Macad::Occt::Quantity_Color^ theItem);
    void UpdateLowerBound(int theLower);
    void UpdateUpperBound(int theUpper);
    void Resize(int theLower, int theUpper, bool theToCopyData);
    bool IsDeletable();
    static Macad::Occt::Quantity_HArray1OfColor^ CreateDowncasted(::Quantity_HArray1OfColor* instance);
    virtual System::Collections::Generic::IEnumerator<Macad::Occt::Quantity_Color^>^ GetEnumerator();
    virtual System::Collections::IEnumerator^ GetEnumerator2() = System::Collections::IEnumerable::GetEnumerator;
}; // class Quantity_HArray1OfColor

//---------------------------------------------------------------------
//  Class  Quantity_PeriodDefinitionError
//---------------------------------------------------------------------
public ref class Quantity_PeriodDefinitionError sealed
    : public Macad::Occt::Standard_DomainError
{

#ifdef Include_Quantity_PeriodDefinitionError_h
public:
    Include_Quantity_PeriodDefinitionError_h
#endif

public:
    Quantity_PeriodDefinitionError(::Quantity_PeriodDefinitionError* nativeInstance)
        : Macad::Occt::Standard_DomainError( nativeInstance )
    {}

    Quantity_PeriodDefinitionError(::Quantity_PeriodDefinitionError& nativeInstance)
        : Macad::Occt::Standard_DomainError( nativeInstance )
    {}

    property ::Quantity_PeriodDefinitionError* NativeInstance
    {
        ::Quantity_PeriodDefinitionError* get()
        {
            return static_cast<::Quantity_PeriodDefinitionError*>(_NativeInstance);
        }
    }

public:
    Quantity_PeriodDefinitionError();
    Quantity_PeriodDefinitionError(System::String^ theMessage);
    Quantity_PeriodDefinitionError(System::String^ theMessage, System::String^ theStackTrace);
    static void Raise(System::String^ theMessage);
    static void Raise();
    /* Method skipped due to unknown mapping: void Raise(stringstream theMessage, ) */
    static Macad::Occt::Quantity_PeriodDefinitionError^ NewInstance(System::String^ theMessage);
    static Macad::Occt::Quantity_PeriodDefinitionError^ NewInstance();
    static Macad::Occt::Quantity_PeriodDefinitionError^ NewInstance(System::String^ theMessage, System::String^ theStackTrace);
    static Macad::Occt::Quantity_PeriodDefinitionError^ CreateDowncasted(::Quantity_PeriodDefinitionError* instance);
}; // class Quantity_PeriodDefinitionError

}; // namespace Occt
}; // namespace Macad
